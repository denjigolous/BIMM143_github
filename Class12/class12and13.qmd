---
title: "Class12 and 13"
author: "Dennis Kim"
format: gfm
editor: visual
---

## Class12

# 1. Bioconductor and DeSeq Setup

Load library packages

```{r, message=FALSE}
library(BiocManager)
library(DESeq2)
```

Read data into R

```{r}
counts <- read.csv("airway_scaledcounts.csv", row.names=1)
metadata <- read.csv("airway_metadata.csv")
```

Take a look at each

```{r}
head(counts)
```

```{r}
head(metadata)
```

Let's make sure that the id column of the metadata match the order of the columns in Count- Data

```{r}
all(metadata$id == colnames(counts))
```

> Q1. How many genes are in this dataset?

```{r}
dim(counts)
```

38694 genes

> Q2. How many 'control' cell lines do we have

```{r}
View(metadata[,2])
```

There are 4 control lines

# Toy differential gene expression

Lets perform some exploratory differential gene expression analysis. Note: this analysis is for demonstration only. NEVER do differential expression analysis this way! Note that the control samples are SRR1039508, SRR1039512, SRR1039516, and SRR1039520.This bit of code will first find the sample id for those labeled control. Then calculate the mean counts per gene across these samples:

```{r}
control <- metadata[metadata[,"dex"]=="control",]
control.counts <- counts[ ,control$id]
control.mean <- rowSums( control.counts )/4
head(control.mean)
```

Side-note: An alternative way to do this same thing using the dplyr package from the tidyverse is shown below. Which do you prefer and why?

```{r, message=FALSE}
library(dplyr)
```

```{r}
control <- metadata %>% filter(dex=="control")
control.counts <- counts %>% select(control$id)
control.mean <- rowSums(control.counts)/4
head(control.mean)
```

> Q3. How would oyu make the above code in either approach more robust?

Use the apply() function Let's extract first extract our counts for control samples as I want to compare this to the counts treated (i.e. with drug) samples.

```{r}
control.inds <- metadata$dex == "control"
control.ids <- metadata$id[control.inds]
control.counts <- counts[, control.ids]
head(control.counts)
```

Let's summarize and get one value per gene in the control experiments. I'll start by taking the average

```{r}
#apply(control.counts, 1, mean)
#can also use `rowMeans()`
control.mean <- rowMeans(control.counts)
```

> Q4. Follow the same procedure for the treated samples (i.e. calculate the mean per gene across drug treated samples and assign to a labeled vector called treated.mean)

```{r}
treated.inds <- metadata$dex == "treated"
treated.ids <- metadata$id[treated.inds]
treated.counts <- counts[, treated.ids]
treated.mean <- rowMeans(treated.counts)

meancounts <- data.frame(control.mean, treated.mean)
head(meancounts)
```

Time to make a plot \> Q5 (a). Create a scatter plot showing the mean of the treated samples against the mean of the control samples. Your plot should look something like the following.

```{r}
plot(meancounts$control.mean, meancounts$treated.mean)
```

> Q5 (b).You could also use the ggplot2 package to make this figure producing the plot below. What geom\_?() function would you use for this plot?

```{r}
library(ggplot2)
ggplot(meancounts, aes(control.mean, treated.mean)) + geom_point()
```

Lets put this on a log scale \> Q6. Try plotting both axes on a log scale. What is the argument to plot() that allows you to do this?

```{r}
plot(meancounts$control.mean, meancounts$treated.mean, log="xy")
```

```{r}
ggplot(meancounts, aes(control.mean, treated.mean)) + geom_point() + scale_x_continuous(trans="log2")
```

The most useful and most straightforward to understand is log2 transformation Let's add a log2 fold-change

```{r}
meancounts$log2fc <- log2(meancounts$treated.mean/meancounts$control.mean)
head(meancounts)
```

We need to remove the genes where we have no count data as taking the log2 of these 0 counts does not tell us anything. \> Q7. What is the purpose of the arr.ind argument in the which() function call above? Why would we then take the first column of the output and need to call the unique() function?

```{r}
#alternative way
zero.vals <- which(meancounts[,1:2]==0, arr.ind=TRUE)
to.rm <- unique(zero.vals[,1])
mycounts <- meancounts[-to.rm,]
head(mycounts)
```

arr.ind() returns the positions of the parts of mean counts from columns 1 to 2 that are equal to 0. We only take the first column and call them unique on the first column in order to ensure that the rows are not removed twice if there are zeros for both values in the samples. Using this method:

```{r}
to.keep <- rowSums(meancounts[,1:2] == 0) == 0
my.counts <- meancounts[to.keep,]
head(my.counts)
```

```{r}
nrow(my.counts)
```

> Q8. Using the up.ind vector above can you determine how many up regulated genes we have at the greater than 2 fc level?

How many genes are upregulated at the log2fc level of +2

```{r}
sum(mycounts$log2fc >= +2)
```

There are 314 upregulated genes

> Q9. Using the down.ind vector above can you determine how many down regulated genes we have at the greater than 2 fc level?

```{r}
sum(mycounts$log2fc <= -2)
```

485 are downregulated

> Q10. Do you trust these results? Why or why not?

We did not do any statistical tests so we do not know if the changes are significant or consistent.

# DESeq2 Analysis

```{r}
library(DESeq2)
```

Like most bioconductor packages, DESeq2 wants it's input and output in a very specific format.

```{r}
dds <- DESeqDataSetFromMatrix(countData=counts, colData=metadata, design=~dex)
```

The main DESeq function is called DESeq

```{r}
dds <- DESeq(dds)
```

```{r}
res <- results(dds)
head(res)
```

```{r}
summary(res)
```

The results function contains a number of arguments to customize the results table. By default the argument alpha is set to 0.1. If the adjusted p value cutoff will be a value other than 0.1, alpha should be set to that value:

```{r}
res05 <- results(dds, alpha=0.05)
summary(res05)
```

# Adding Annotation Data

Load packages

```{r}
library("AnnotationDbi")
library("org.Hs.eg.db")
```

All the key types we can use to label

```{r}
columns(org.Hs.eg.db)
```

We can use the mapIds() function to add individual columns to our results table. We provide the row names of our results table as a key, and specify that keytype=ENSEMBL. The column argument tells the mapIds() function which information we want, and the multiVals argument tells the function what to do if there are multiple possible values for a single input value. Here we ask to just give us back the first one that occurs in the database.

```{r}
res$symbol <- mapIds(org.Hs.eg.db,
                    keys=row.names(res), # Our genenames
                    keytype="ENSEMBL", # The format of our genenames
                    column="SYMBOL", # The new format we want to add
                    multiVals="first")
```

```{r}
head(res)
```

> Q11. Run the mapIds() function two more times to add the Entrez ID andUniProt accession and GENENAME as new columns called resentrez, uniprot and res\$genename.

```{r}
res$entrez <- mapIds(org.Hs.eg.db,
                    keys=row.names(res),
                    column="ENTREZID",
                    keytype="ENSEMBL",
                    multiVals="first")
res$uniprot <- mapIds(org.Hs.eg.db,
                    keys=row.names(res),
                    column="UNIPROT",
                    keytype="ENSEMBL",
                    multiVals="first")
res$genename <- mapIds(org.Hs.eg.db,
                    keys=row.names(res),
                    column="GENENAME",
                    keytype="ENSEMBL",
                    multiVals="first")
```

```{r}
head(res)
```

Arrange and order by adjusted p-value

```{r}
ord <- order( res$padj )
#View(res[ord,])
head(res[ord,])
```

Write the ordered significant results

```{r}
write.csv(res[ord,], "deseq_results.csv")
```

# Volcono Plots

A major summary figure of this type of analysis is called a volcano plot, the idea is to keep our inner biologist and inner statistician happy

```{r}
plot(res$log2FoldChange, res$padj)
```

Improve this plot by taking the log of the p-value axis

```{r}
plot(res$log2FoldChange, log(res$padj))
```

I want to flip this y axis so the values I care about (i.e. the low p-values or high log(p-values)) are at the top of the axis

```{r}
plot(res$log2FoldChange, -log(res$padj), xlab="Log2(FoldChange)", ylab="-Log(P-value)")
# Add some cut-off lines
abline(v=c(-2,2), col="darkgray", lty=2)
abline(h=-log(0.05), col="darkgray", lty=2)
```

Colors

```{r}
# Setup our custom point color vector
mycols <- rep("gray", nrow(res))
mycols[ abs(res$log2FoldChange) > 2 ] <- "red"
inds <- (res$padj < 0.01) & (abs(res$log2FoldChange) > 2 )
mycols[ inds ] <- "blue"
# Volcano plot with custom colors
plot( res$log2FoldChange, -log(res$padj),
col=mycols, ylab="-Log(P-value)", xlab="Log2(FoldChange)" )
# Cut-off lines
abline(v=c(-2,2), col="gray", lty=2)
abline(h=-log(0.1), col="gray", lty=2)
```

## Class13

# Section 1. Differential Expression Analysis

```{r, message=FALSE}
library(DESeq2)
```

Load the data files

```{r}
metaFile <- "GSE37704_metadata.csv"
countFile <- "GSE37704_featurecounts.csv"

# Import metadata and take a peak
colData = read.csv(metaFile, row.names=1)
head(colData)
```

```{r}
# Import countdata
countData = read.csv(countFile, row.names=1)
head(countData)
```

> Q. Complete the code below to remove the troublesome first column from countData

```{r}
# Note we need to remove the odd first $length col
countData <- as.matrix(countData[,-1])
head(countData)
```

Check that my metadata and count data match

```{r}
rownames(colData)
```

```{r}
colnames(countData)
```

```{r}
rownames(colData)==colnames(countData)
```

```{r}
all(rownames(colData) == colnames(countData))
```

This looks better but there are lots of zero entries in there so let's get rid of them as we have no data for these.

> Q. Complete the code below to filter countData to exclude genes (i.e. rows) where we have 0 read count across all samples (i.e. columns).

```{r}
#head(countData)
to.keep <- rowSums(countData) != 0
countData <- countData[to.keep,]

nrow(countData)
head(countData)
```

## Run DESeq2

```{r}
library(DESeq2)
```

```{r}
head(colData)
```

Set up the object that DESeq needs for analysis with the lovely log function, and run DESeq analysis

```{r}
dds = DESeqDataSetFromMatrix(countData=countData,
                             colData=colData,
                             design=~condition)
dds = DESeq(dds)
```

```{r}
dds
res <- results(dds)
res
```

Next, get results for the HoxA1 knockdown versus control siRNA (remember that these were labeled as "hoxa1_kd" and "control_sirna" in our original colData metaFile input to DESeq, you can check this above and by running resultsNames(dds) command).

```{r}
res = results(dds, contrast=c("condition", "hoxa1_kd", "control_sirna"))
```

> Q. Call the summary() function on your results to get a sense of how many genes are up or down-regulated at the default 0.1 p-value cutoff.

```{r}
summary(res)
```

4349 upregulated, 4396 downregulated

## Volcono Plot

```{r}
plot( res$log2FoldChange, -log(res$padj) )
```

```{r}
# Make a color vector for all genes
mycols <- rep("gray", nrow(res) )
mycols[ abs(res$log2FoldChange) > 2 ] <- "red"
inds <- (res$padj < 0.01) & (abs(res$log2FoldChange) > 2 )
mycols[ inds ] <- "blue"
plot( res$log2FoldChange, -log(res$padj), col=mycols, xlab="Log2(FoldChange)", ylab="-Log(P-value)" )
abline(v=c(-2,2), lty=2)
```

## Adding Gene Annotation

Since we mapped and counted against the Ensembl annotation, our results only have information about Ensembl gene IDs. However, our pathway analysis downstream will use KEGG pathways, and genes in KEGG pathways are annotated with Entrez gene IDs. So lets add them as we did the last day.

> Q. Use the mapIDs() function multiple times to add SYMBOL, ENTREZID and GENENAME annotation to our results by completing the code below.

```{r}
library("AnnotationDbi")
library("org.Hs.eg.db")

columns(org.Hs.eg.db)

res$symbol = mapIds(org.Hs.eg.db,
                    keys=row.names(res), 
                    keytype="ENSEMBL",
                    column="SYMBOL",
                    multiVals="first")

res$entrez = mapIds(org.Hs.eg.db,
                    keys=row.names(res),
                    keytype="ENSEMBL",
                    column="ENTREZID",
                    multiVals="first")

res$name =   mapIds(org.Hs.eg.db,
                    keys=row.names(res),
                    keytype="ENSEMBL",
                    column="GENENAME",
                    multiVals="first")

head(res, 10)
```

> Q. Finally for this section let's reorder these results by adjusted p-value and save them to a CSV file in your current project directory.

```{r}
res = res[order(res$pvalue),]
write.csv(res, "deseq_results.csv")
```

# Section 2 Pathway Analysis

## KEGG Pathways

Now we can load the packages and setup the KEGG data-sets we need.

```{r}
library(pathview)
```

```{r}
library(gage)
library(gageData)

data(kegg.sets.hs)
data(sigmet.idx.hs)

# Focus on signaling and metabolic pathways only
kegg.sets.hs = kegg.sets.hs[sigmet.idx.hs]

# Examine the first 3 pathways
head(kegg.sets.hs, 3)
```

The main gage() function requires a named vector of fold changes, where the names of the values are the Entrez gene IDs.

Note that we used the mapIDs() function above to obtain Entrez gene IDs (stored in `res$entrez`) and we have the fold change results from DESeq2 analysis (stored in `res$log2FoldChange`).

```{r}
foldchanges = res$log2FoldChange
names(foldchanges) = res$entrez
head(foldchanges)
```

Now, let's run the gage pathway analysis.

```{r}
# Get the results
keggres = gage(foldchanges, gsets=kegg.sets.hs)
```

Now lets look at the object returned from gage().

```{r}
attributes(keggres)
```

```{r}
# Look at the first few down (less) pathways
head(keggres$less)
```

Each `keggres$less` and `keggres$greater` object is data matrix with gene sets as rows sorted by p-value.

The top "less/down" pathways is "Cell cycle" with the KEGG pathway identifier hsa04110.

Now, let's try out the pathview() function from the pathview package to make a pathway plot with our RNA-Seq expression results shown in color. To begin with lets manually supply a pathway.id (namely the first part of the "hsa04110 Cell cycle") that we could see from the print out above.

```{r, message=FALSE}
pathview(gene.data=foldchanges, pathway.id="hsa04110")
```

![](hsa04110.pathview.png)

```{r, message=FALSE}
# A different PDF based output of the same data
pathview(gene.data=foldchanges, pathway.id="hsa04110", kegg.native=FALSE)
```

Now, let's process our results a bit more to automagicaly pull out the top 5 upregulated pathways, then further process that just to get the pathway IDs needed by the pathview() function. We'll use these KEGG pathway IDs for pathview plotting below.

```{r}
## Focus on top 5 upregulated pathways here for demo purposes only
keggrespathways <- rownames(keggres$greater)[1:5]

# Extract the 8 character long IDs part of each string
keggresids = substr(keggrespathways, start=1, stop=8)
keggresids
```

Finally, lets pass these IDs in keggresids to the pathview() function to draw plots for all the top 5 pathways.

```{r, message=FALSE}
pathview(gene.data=foldchanges, pathway.id=keggresids, species="hsa")
```

![](hsa04640.pathview.png)\
![](hsa04630.pathview.png)\
![](hsa00140.pathview.png)\
![](hsa04142.pathview.png)\
![](hsa04330.pathview.png)

# Section 3 Gene Ontology

We can also do a similar procedure with gene ontology. Similar to above, go.sets.hs has all GO terms. go.subs.hs is a named list containing indexes for the BP, CC, and MF ontologies. Let's focus on BP (a.k.a Biological Process) here.

```{r}
data(go.sets.hs)
data(go.subs.hs)

# Focus on Biological Process subset of GO
gobpsets = go.sets.hs[go.subs.hs$BP]

gobpres = gage(foldchanges, gsets=gobpsets, same.dir=TRUE)

lapply(gobpres, head)
```

# Section 4 Reactome Analysis

Reactome is database consisting of biological molecules and their relation to pathways and processes. Let's now conduct over-representation enrichment analysis and pathway-topology analysis with Reactome using the previous list of significant genes generated from our differential expression results above.

First, Using R, output the list of significant genes at the 0.05 level as a plain text file:

```{r}
sig_genes <- res[res$padj <= 0.05 & !is.na(res$padj), "symbol"]
print(paste("Total number of significant genes:", length(sig_genes)))
```

```{r}
write.table(sig_genes, file="significant_genes.txt", row.names=FALSE, col.names=FALSE, quote=FALSE)
```

> Q: What pathway has the most significant "Entities p-value"? Do the most significant pathways listed match your previous KEGG results? What factors could cause differences between the two methods?

Signal transduction and gene expression has the most significant pathway.
